# algorithmsAndDesignPatterns

# 算法与设计模式笔记[^1]

## 设计模式

“每一个模式描述了一个在我们周围不断重复发生的问题，以及该问题的解决方案的核心。这样，你就能一次又一次地使用该方案而不必做重复劳动”。设计模式的核心在于提供了相关问题的解决方案，使得人们可以更加简单方便地复用成功的设计和体系结构。

创建型模式与对象的创建有关；结构型模式处理类或对象的组合；行为型模式对类或对象怎么交互和怎么分配职责进行描述。

### 创建型设计模式

创造型模式抽象了实例化过程，他们帮助一个系统独立于如何创建、组合和标识它的那些对象。一个类创建型模式使用继承改变被实例化的类，而一个对象创建型模式将实例化委托给另一个对象。

在这些模式中有两个不断出现的主旋律：
- 第一，他们都将关于该系统使用哪些具体的类的信息封装起来。
- 第二，他们隐藏了这些类的实例是如何被创建和放在一起的。整个系统关于这些对象所知道的是由抽象类所定义的接口。

因此，创建型模式在什么被创建、谁创建他、他是怎样被创建的，以及如何创建这些方面给予了很大的灵活性。它们允许使用结构和功能差别很大的“产品”对象配置一个系统。配置可以是静态的（即在编译时指定），也可以时动态的（在运行时指定）。

#### 1. Factory Method (工厂模式)

定义一个用于创建对象的接口，让子类决定实例化哪个类。 Factory Method 使用一个类的实例化延迟到其他子类。

#### 2. Abstract Factory (抽象工厂模式)

提供一个创建一系列相关或互相依赖对象的接口，而无须指定它们具体的类。 Abstract Factory 是围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。

#### 3. Builder (生成器模式)

将一个复杂对象的创建与它的表示分离，使得同样的构建过程可以创建不同的表示。

#### 4.Prototype (原型模式)

用原型实例指定创建对象的种类，并且通过复制这些原型创建新的对象。

#### 5. Singleton (单例模式)

保证一个类仅有一个实例，并提供一个访问它的全局访问点。

#### 创建型模式比较

用于系统创建的那些对象的类对系统进行参数化有两种常用方法:生成创建对象的类的子类和对系统进行参数化的方法。前者对应于使用Factory Method模式，其主要缺点是仅为了改变产品类就可能需要创建一个新的子类。这种改变可能级联发生，例如，如果产品的创建者本身是一个工厂方法创建的，那么也必须重定义它的创建者。后者更多地依赖于对象的复合，定义一个对象负责明确产品对象的类，并将它作为该系统的参数。这是 Abstract Factory、Builder和Prototype模式的关键特征，都涉及创建一个新的负责创建产品对象的“工厂对象”。AbstractFactory由这个工厂对象产生多个对象。Builder 由这个工厂对象使用一个相对复杂的协议，逐步创建一个复杂产品。Prototype由该工厂对象通过复制原型对象来创建产品对象。在这种情况下，由于原型负责返回产品对象，所以工厂对象和原型是同一个对象。



### 结构型设计模式

结构型设计模式设计如何组合类和对象以获得更大的结构。结构型类模式采用继承机制来组合接口或实现。一个简单的例子是采用多重继承方法将两个以上的类组合成一个类，结果这个类包含了所有父类的性质。

结构型对象模式不是对接口和实现进行组合，而是描述了如何对一些对象进行组合，从而实现新功能的一些方法。因为可以在运行时刻改变对象组合关系，所以对象组合方式具有更大的灵活性，而这种机制用静态类组合是不可能实现的。

#### 1. Adapter (适配器模式)

将一个类的接口转换成客户希望的另外一个接口。 Adapter 模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。

#### 2. Bridge (桥接模式)

将抽象部分与其实现部分分离，使它们都可以独立地变化。

#### 3. Composite (组合模式)

将对象组合成树型结构以表示“部分-整体”的层次结构。 Composite 使得用户对单个对象和组合对象的使用具有一致性。

#### 4. Decorator (装饰模式)

动态地给一个对象添加一些额外的职责。就增加功能而言，Decorator 模式比生成子类更加灵活。

#### 5. Facade (外观模式)

为子系统中的一组接口提供一个一致的界面，Facade 模式定义了一个高层接口，这个接口使得这一个子系统更加容易使用。

#### 6. Flyweight (享元模式)

运用共享技术有效地支持大量细粒度的对象

#### 7. Proxy (代理模式)

为其他对象提供一种代理以控制对这个对象的访问。

#### 结构型模式比较

Adapter模式和 Bridge模式具有一些功能特征，都给另一个对象提供了一定程度上的间接性,因而有利于系统的灵活性,另外都涉及从自身以外的一个接口向这个对象转发请求。Adapter模式主要是为解决两个已有接口之间不匹配的问题，不考虑这些接口是怎样实现的，也不考虑它们各自可能会如何演化。这种方式不需要对两个独立设计的类中的任何一个进行重新设计，就能够使它们协同工作。Bridge模式则对抽象接口与它的(可能是多个）实现部分进行桥接。虽然这一模式运行使用者修改实现它的类，但是它仍然为用户提供了一个稳定的接口，也会在系统演化时适应新的实现。Adapter模式和 Bridge模式通常被用于软件生命周期的不同阶段，针对不同的问题。Adapter模式在类已经设计好后实施;而 Bridge模式在设计类之前实施。

Composite模式和 Decorator模式具有类似的结构，说明它们都是基于递归组合来组织可变数目的对象。Decorator 旨在能够不需要生成子类即可给对象添加职责，这避免了静态实现所有功能组合而导致子类急剧增加。Composite旨在构造类，使多个相关的对象能够以统一的方式处理，而多重对象可以被当作一个对象来处理，重点在于表示。两者通常协同使用。

Decorator模式和Proxy模式都描述了怎样为对象提供一定程度上的间接引用。Proxy模式构成一个对象并为用户提供一致的接口，与Decorator模式不同的是，Proxy模式不能动态地添加或分离性质，也不是为递归组合而设计的，它强调一种关系(Proxy 与它的实体之间的关系)，这种关系可以静态地表达。其目的是，当直接访问一个实体不方便或不符合需要时，为这个实体提供一个替代者，例如，实体在远程设备上，访问受到限制或者实体是持久存储的。在Proxy模式中，实体定义了关键功能，而 Proxy提供(或拒绝）对它的访问。在 Decorator模式中，组件仅提供了部分功能，而一个或多个Decorator 负责完成其他功能。Decorator模式适用于编译时不能（至少不方便）确定对象的全部功能的情况。


### 行为型设计模式

行为模式涉及算法和对象间职责的分配。行为模式不仅描述对象或类的模式，还描述它们之间的通信模式。这些模式刻画了在运行时难以跟踪的、复杂的控制流。它们将用户的注意力从控制流转移到对象间的联系方式上来。

行为类模式使用继承机制在类间分派行为。

行为对象模式使用对象复合而不是继承。

#### 1. Chain of Responsibility (责任链模式)

使用多个对象都有机会处理请求，从而避免请求的发送者和接受者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。

#### 2. Command (命令模式)

将一个请求封装为一个对象，从而使得可以用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撤销的操作。 Command 模式的请求以命令的形式包裹在对象中，并传给调用对象。调用对象寻找可以处理该命令的合适的对象，并把该命令传给相应的对象，该对象执行命令。

#### 3. Interpreter (解释器模式)

给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。


#### 4. Iterator (迭代器模式)

提供一种方法顺序方位一个聚合对象中的各个元素，且不需要暴露该对象的内部表示。

#### 5. Mediator (中介者模式)

用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地互相引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。

#### 6. Memento (备忘录模式)

在不破坏封装性的前提下捕获一个对象的内部状态，并在对象之外保存这个状态。这样以后就可以将对象恢复到原先保存的状态。

#### 7. Observer (观察者模式)

定义对象间的一种一对多的依赖关系，当一个对象的状态改变时，所有依赖于它的对象都得到通知并被自动更新。

#### 8. State (状态模式)

允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它的类。

#### 9. Strategy (策略模式)

定义一系列的算法。把它们一个个封装起来，并且使它们可以互相替换。此模式使得算法可以独立于使用它们的客户而变化。

#### 10. Template Method (模板方法)

定义一个操作中的算法骨架，而将一些步骤延迟到子类中。 Template Method 使得子类可以不改变一个算法的结构即可重新定义该算法的某些特定步骤。

#### 11. Visitor (访问者模式)

表示一个作用于某对象结构中的各元素的操作。它允许在不改变各元素的类的前提下定义作用于这些元素的新操作。


#### 行为模式比较

很多行为模式注重封装变化。当一个程序的某个方面的特征经常发生改变时，这些模式就定义一个封装这个方面的对象。这样，当该程序的其他部分依赖于这个方面时，它们都可以乓此对象协作。这些模式通常定义一个抽象类来描述这些封装变化的对象，并且通常该模式依搪这个对象来命名。例如:
- 一个 Strategy对象封装一个算法。
- 一个State对象封装一个与状态相关的行为。
- 一个Mediator对象封装对象间的协议。
- 一个Iterator对象封装访问和遍历一个聚集对象中的各个组件的方法。




[^1]:算法与设计模式基础部分的内容参考自软考指定用书《软件设计师教程 第5版》，同时部分资料参考自知乎和[菜鸟教程](https://www.runoob.com/design-pattern/design-pattern-tutorial.html)。
